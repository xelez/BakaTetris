
# Тетрис на двоих

Развитие всем известной игры с элементами мультиплеера, азарта и подлости.

## Идея

Два игрока параллельно играют в тетрис. Каждый видит и свою игру, и что происходит у второго игрока.
Задача - набрать больше очков, чем у противника. (???) При этом через каждый N'ый ход на поле делает другой игрок.
Тем самым он может либо заподлить, либо помочь. Это уже как пойдёт.

## Процесс с точки зрения игрока

 * Игрок открывает толстый(?) клиент на своём компьютере.
 * Он автоматически находит сервера и подключается к одному из них.
 * _Игрок видит список открытых игр._
 * _Он может либо подключится к уже существующей игре, либо создать новую._
 * Игрок автоматически подключается либо к уже открытой игре либо создаётся новая.
 * Если он подключается к уже существующей игре, то сразу начинается собственно игра.
 * Если он создаёт новую, то начинается процесс ожидания второго игрока.
 * После окончания игры игроки возвращаются к списку игр.

## Техническая часть

Система включает в себя:

 * Толстый клиент на Qt.
 * Сервис поиска серверов через UPD Multicast.
 * Сервера "лобби"(нужно придумать более адекватное название) -- отвечает за регистрацию, авторизацию, списки игр.
 * Сервера игр (умеют обрабатывать логику игр и сообщать результат).
 * Сервера MongoDB для хранения данных о пользователях и результатов игр.
 * Сервера RabbitMQ для общения между игровыми серверами и серверами "лобби".

**TODO**: сюда нужна картинка и обоснование выбора такой архитектуры. Что-то вроде: Данная архитектура позволяет разделить реализацию на несколько
независимых, слабо взаимодействующих сущностей, что приводит к высокой отказоустойчивости и масштабируемости.


### Сервис поиска серверов

Сервер слушает на Multicast адресе `224.0.0.111` и `13334` порту (это настраивается). При получении любого запроса на свой адрес и порт в ответ
отправляет заранее заданный список адресов серверов.

В сети может быть запущено несколько серверов поиска на разных компьютерах. В таком случае, клиент получит списки серверов от их обоих (что нормально).
При отключении одного из серверов оставшийся продолжит работать.

Реализация - однопоточный сервер на языке Python. В данном случае узким местом будет сеть, а не вычислительная скорость, поэтому многопоточность не требуется.
(Но если сильно хочется, можно запустить несколько таких сервисов на одном компьютере, но делать этого не рекомендуется).

### Толстый клиент

Клиент посылает запрос на Multicast адрес и получает в ответ от сервиса поиска список серверов "лобби". Выбирает из списка случайный и подключается к нему.
Если он не отвечает, пробует подключиться к другому случайному.

Общение с сервером "лобби" осуществляется через `REST`. Протокол описан далее.
Клиент регистрируется либо авторизуется на сервере "лобби" и получает токен для дальнейших операций на сервере.

После чего клиент через небольшие промежутки времени (случайное число миллисекунд, примерно 1-2 с.) заправшивает список открытый игр (т.е. игр,
к которым можно присоедениться) у сервера и отображает пользователю.

Пользователь может либо создать новую игру, либо присоедениться к существующей.

Как при присоединении к существующей, так и при создании новой игры пользователю предоставляется ip игрового сервера и токен, при помощи которого он может
подключится к этому серверу. Взаимодействие с этим сервером происходит при помощи технологии `websockets`.

После подключения начинается ожидание второго игрока, и, когда он подключился и готов, сама игра.

После завершения игры пользователь возвращается обратно к списку игр.

Технологии реализации: C++, Qt, boost, etc. ???

### Сервера "лобби"

Предоставляют REST-api для толстых клиентов. Сохраняют данные об играх и пользователях в MongoDB. Общаются с игровыми серверами через RabbitMQ.

Через RabbitMQ сервер "лобби" находит игровой сервер для новых клиентов, получает информацию о состоянии игр и их результатах.

Сервера "лобби" являются stateless, так как хранят всё своё состояние в БД. Это позволяет легко добавлять и убирать сервера из системы в зависимости
от нагрузки или при выходе из строя некоторых из них.

Реализован на node.js. Асинхронный.

### Игровые сервера

Общаются с клиентами через socket.io и с серверами лобби через RabbitMQ.

При включении посылают сообщение со своим адресом в rabbitmq. Также сообщают о подключении пользователей к играм и об их резульатах.

После начала игры обратывают игровую логику, получают информацию о ходах от игроков, обеспечивают синхронизацию игроков.

Каждый сервер может обрабатывать несколько игр одновременно. Протокол взаимодействия описан ниже.

Реализован на node.js. Асинхронный.

## Протоколы взаимодействия и обоснование их выбора

### клиент <-> сервис поиска (UDP Multicast)
Multicast - единственный актуальный способ найти сервера в локальной сети, не имея их точного ip-адреса.
(Это справедливо при условии, что мы не контролируем DNS/DHCP сервера в сети, что подразумевается).
(Также стоит заметить, что IP Broadcast устарел, не поддерживается в IPv6 и имеет специфичные проблемы, описание которых выходит за рамки даного отчёта)

Клиент отправляет "hello" серверу, слушающему на Multicast-адресе. Сервер отправляет обратно
список вида "ip1:port1;ip2:port2;...;ipN:portN".

### Описание REST-api сервера "лобби"
Успешность вызова определяется кодом возврата:

 * 400 - Bad Request - неверный запрос;
 * 403 - Forbidden - нет прав;
 * 404 - Not Found - такого объекта нет;
 * 200 - Ok - запрос выполнен.

| path           | method | параметры      | возвращает                                                |
|----------------|--------|----------------|-----------------------------------------------------------|
| /signup        | POST   | user, password | auth_token                                                |
| /signin        | POST   | user, password | auth_token                                                |
| /games         | GET    | auth_token     | список всех игр (нужно ли?)                               |
| /games/open    | GET    | auth_token     | список игр, к которым можно присоедениться                |
| /games         | POST   | auth_token     | game_id(id  новой игры), gameserver_ip, create_game_token |


Параметры передаются через json, возвращается опять же json.

Пример списка игр, к которым можно присоедениться:

```javascript
[
    {
        id: "someid1", // mongodb ObjectId probably, but i'm not sure
        creator: "user1", // unicode!
        server_ip: "127.0.1.1:22222",
        join_token: "abracadabra" // about 16 random alphanumeric characters
    },
    {
        id: "someid2",
        creator: "юзер2",
        server_ip: "127.0.1.2:22223",
        join_token: "abacabacaca"
    }
]

```

В `auth_token` шифруется информация об имени пользователя, для чего выдан токен, кем выдан и т.п. Токен подписывается при помощи ключа сервера.
Клиент не должен и не может расшифровать токен, только использовать по назначению.

`create_game_token` и `join_token` -- строки из 16 случайных букв и цифр. Генерируются игровым сервером, передаются в лобби сервера через RabbitMQ.

### Описание отправляемых и принимаемых сообщений RabbitMQ

#### Очередь "game_info"

Очередь с подтверждениями обработки сообщений.
В неё игровые сервера посылают сообщения и они равномерно распределяются между серверами lobby.

Сообщения:

1. Игра создана на сервере.
2. В игру зашел 2ой игрок, игра началась.
3. Игра завершена с таким-то результатом.

#### Exchange "pong"

Тип fanout. Т.е. сообщения рассылаются всем подписчикам. Без подтверждений.

Игровые сервера уведомляют через неё сервера лобби о своём существовании.

Единственное сообщение: `ip:port`.

#### Exchange "ping"

Тип fanout. Без подтверждений.

Сервера лобби через него просят все игровые сервера сообщить о своём существовании.

Единственное сообщение: `ping`.

### Socket.io

От сервера клиентам:
1. Игра началась
2. Новый блок сверху. Указывается какой именно, и кто на каком поле ходит + состояние полей??? (а надо ли).
3. Игра завершена. Указывается причина (выигрыш/дисконнект второго/другое), и кто победил.

От клиентов серверу и 2ому клиенту:
1. Позиция текущего падающего блока.
2. Блок закончил падать.

## Устойчивость и надежность системы

### Падение сервиса поиска
На запросы продолжает второй(3ий, 4ый..) сервер. Упавший сервис можно поднять на другом узле сети.

### Падение сервера лобби
Клиент переподключается к другому серверу из списка, полученного от сервиса поиска.
Так как сервера лобби не хранят состояний клиент просто продолжает работать как и раньше.
Можно поднять сервер лобби на любом компьютере, при условии что он есть в списке адресов сервиса поиска.

### Падение игрового сервера
Завершаются все игры, идущие на этом сервере. Остальная система работает без изменений.
Клиент возвращается к списку игр.

### Падение сервера RabbitMQ
RabbitMQ возможно настроить так, чтобы падение одного сервера на влияло на систему. 

### Падение сервера MongoDB
MongoDB возможно настроить так, чтобы падение одного сервера на влияло на систему. 

### Падение клиента
У пользователя есть 30 секунд чтобы зайти в систему снова и вернуться в игру.


