
# Тетрис на двоих

Развитие всем известной игры с элементами мультиплеера, азарта и подлости.

## Идея

Два игрока параллельно играют в тетрис. Каждый видит и свою игру, и что происходит у второго игрока.
Задача - набрать больше очков, чем у противника. (???) При этом через каждый N'ый ход на поле делает другой игрок.
Тем самым он может либо заподлить, либо помочь. Это уже как пойдёт.

## Процесс с точки зрения игрока

 * Игрок открывает толстый(?) клиент на своём компьютере.
 * Он автоматически находит сервера и подключается к одному из них.
 * Игрок видит список открытых игр.
 * Он может либо подключится к уже существующей игре, либо создать новую.
 * Если он подключается к уже существующей игре, то сразу начинается собственно игра.
 * Если он создаёт новую, то начинается процесс ожидания второго игрока.
 * После окончания игры игроки возвращаются к списку игр.

## Техническая часть

Система включает в себя:

 * Толстый клиент на Qt.
 * Сервис поиска серверов через UPD Multicast.
 * Сервера "лобби"(нужно придумать более адекватное название) -- отвечает за регистрацию, авторизацию, списки игр.
 * Сервера игр (умеют обрабатывать логику игр и сообщать результат).
 * Сервера MongoDB для хранения данных о пользователях и результатов игр.
 * Сервера RabbitMQ для общения между игровыми серверами и серверами "лобби".

**TODO**: сюда нужна картинка и обоснование выбора такой архитектуры. Что-то вроде: Данная архитектура позволяет разделить реализацию на несколько
независимых, слабо взаимодействующих сущностей, что приводит к высокой отказоустойчивости и масштабируемости.


### Сервис поиска серверов

Сервер слушает на Multicast адресе `224.0.0.111` и `13334` порту (это настраивается). При получении любого запроса на свой адрес и порт в ответ
отправляет заранее заданный список адресов серверов.

В сети может быть запущено несколько серверов поиска на разных компьютерах. В таком случае, клиент получит списки серверов от их обоих (что нормально).
При отключении одного из серверов оставшийся продолжит работать.

Реализация - однопоточный сервер на языке Python. В данном случае узким местом будет сеть, а не вычислительная скорость, поэтому многопоточность не требуется.
(Но если сильно хочется, можно запустить несколько таких сервисов на одном компьютере, но делать этого не рекомендуется).

### Толстый клиент

Клиент посылает запрос на Multicast адрес и получает в ответ от сервиса поиска список серверов "лобби". Выбирает из списка случайный и подключается к нему.
Если он не отвечает, пробует подключиться к другому случайному.

Общение с сервером "лобби" осуществляется через `REST`. Протокол описан далее.
Клиент регистрируется либо авторизуется на сервере "лобби" и получает токен для дальнейших операций на сервере.

После чего клиент через небольшие промежутки времени (случайное число миллисекунд, примерно 1-2 с.) заправшивает список открытый игр (т.е. игр,
к которым можно присоедениться) у сервера и отображает пользователю.

Пользователь может либо создать новую игру, либо присоедениться к существующей.

Как при присоединении к существующей, так и при создании новой игры пользователю предоставляется ip игрового сервера и токен, при помощи которого он может
подключится к этому серверу. Взаимодействие с этим сервером происходит при помощи технологии `socket.io`, работающей поверх websockets.

После подключения начинается ожидание второго игрока, и, когда он подключился и готов, сама игра.

После завершения игры пользователь возвращается обратно к списку игр.

Технологии реализации: C++, Qt, boost, etc. ???

### Сервера "лобби"

Предоставляют REST-api для толстых клиентов. Сохраняют данные об играх и пользователях в MongoDB. Общаются с игровыми серверами через RabbitMQ.

При включении сервер отправляет сообщение в rabbitmq. В ответ на него все работающие игровые сервера присылают свои ip-адреса.
Также сервер принимает сообщения от игровых серверов о включении, выключении, присоединений игроков к ним и результатах игр. Эта информация заносится в БД.
Сообщения о включении/выключении игровых серверов обрабатываются всеми серверами "лобби", а другие сообщения обратываются только один раз любым из серверов
(кому rabbitmq направит, тот и обработает).

Сервера "лобби" являются stateless. Хранят всё состояние в БД, кроме списка живых игровых серверов. Последние получаются при запуске и поддерживаются в
процессе работы.

Реализован на node.js. Асинхронный.

### Игровые сервера

Общаются с клиентами через socket.io и с серверами лобби через RabbitMQ.

При включении посылают сообщение со своим адресом в rabbitmq. Также сообщают о подключении пользователей к играм и об их резульатах.

После начала игры обратывают игровую логику, получают информацию о ходах от игроков, обеспечивают синхронизацию игроков.

Каждый сервер может обрабатывать несколько игр одновременно. Протокол взаимодействия описан ниже.

Реализован на node.js. Асинхронный.

## Протоколы взаимодействия и обоснование их выбора

### UDP Multicast

### Описание REST-api

### Описание отправляемых и принимаемых сообщений RabbitMQ

### Socket.io

## Устойчивость и надежность системы

### Падение сервиса поиска
На запросы продолжает второй(3ий, 4ый..) сервер. Упавший сервис можно поднять на другом узле сети.

### Падение сервера лобби
Клиент переподключается к другому серверу из списка, полученного от сервиса поиска.
Так как сервера лобби не хранят состояний клиент просто продолжает работать как и раньше.
Можно поднять сервер лобби на любом компьютере, при условии что он есть в списке адресов сервиса поиска.

### Падение игрового сервера
Завершаются все игры, идущие на этом сервере. Остальная система работает без изменений.
Клиент возвращается к списку игр.

### Падение сервера RabbitMQ
RabbitMQ возможно настроить так, чтобы падение одного сервера на влияло на систему. 

### Падение сервера MongoDB
MongoDB возможно настроить так, чтобы падение одного сервера на влияло на систему. 

### Падение клиента
У пользователя есть 30 секунд чтобы зайти в систему снова и вернуться в игру.


